# GoIT Algorithm Final Project

## Завдання 1. Структури даних. Сортування. Робота з однозв'язним списком

### Опис
Реалізація операцій з однозв'язним списком (singly linked list):
- Реверсія списку шляхом зміни посилань між вузлами
- Сортування списку алгоритмом insertion sort
- Об'єднання двох відсортованих списків в один відсортований

### Реалізація
- `Node` - клас вузла списку
- `LinkedList` - клас однозв'язного списку з методами `append()`, `to_list()`, `from_list()`
- `reverse_list()` - реверсія списку (ітеративний підхід)
- `insertion_sort_list()` - сортування вставками
- `merge_sorted_lists()` - об'єднання двох відсортованих списків

### Запуск
```bash
python task1/main.py
```

### Приклад виводу
```
1. Реверсія:
До: [1, 2, 3, 4, 5]
Після: [5, 4, 3, 2, 1]

2. Сортування:
До: [4, 2, 1, 3, 5]
Після: [1, 2, 3, 4, 5]

3. Об'єднання відсортованих списків:
Список 1: [1, 3, 5]
Список 2: [2, 4, 6]
Об'єднаний: [1, 2, 3, 4, 5, 6]
```

### Складність
- **Реверсія**: O(n) за часом, O(1) за пам'яттю
- **Сортування вставками**: O(n^2) за часом, O(1) за пам'яттю
- **Об'єднання**: O(n + m) за часом, O(1) за пам'яттю (де n, m - довжини списків)

---

## Завдання 2. Рекурсія. Створення фрактала "Дерево Піфагора"

### Опис
Програма генерує фрактал "Дерево Піфагора" за допомогою рекурсії та візуалізує його за допомогою бібліотеки `turtle`. Користувач може вказати рівень рекурсії для контролю складності фракталу.

![Дерево Піфагора (рівень 10)](pythagorean_tree_10.png)

### Особливості
- Рекурсивна генерація фракталу
- Змінна ширина ліній: товстіші на початкових рівнях, тонші на глибоких
- Кожна гілка має кут 45(deg) і зменшується на 30% (коефіцієнт 0.7) на кожному рівні

### Запуск
```bash
python task2/main.py
```

### Параметри
- **Рівень рекурсії**: вводиться користувачем (за замовчуванням 5)
- **Початкова довжина**: 100 пікселів
- **Коефіцієнт зменшення**: 0.7
- **Кут розгалуження**: 45(deg)

### Алгоритм
1. Малюється вертикальна лінія (стовбур)
2. На кожному рівні рекурсії створюються дві гілки під кутом 45(deg)
3. Довжина гілок зменшується на 30% на кожному рівні
4. Процес повторюється до досягнення глибини 0

### Складність
- **Часова**: O(2^n), де n - рівень рекурсії
- **Просторова**: O(n) через стек рекурсивних викликів

---

## Завдання 3. Дерева, алгоритм Дейкстри

### Опис
Реалізація алгоритму Дейкстри для знаходження найкоротших шляхів у зваженому графі з використанням бінарної купи (піраміди). Алгоритм обчислює найкоротші відстані від початкової вершини до всіх інших вершин графа.

### Реалізація
- `dijkstra()` - алгоритм Дейкстри з використанням бінарної купи (`heapq`)
- `get_path()` - відновлення шляху від початкової до цільової вершини
- Граф представлений як словник, де ключі - вершини, значення - словники сусідів з вагами ребер

### Особливості
- Використання бінарної купи (min-heap) для оптимізації вибору вершин
- Автоматичне обчислення найкоротших шляхів до всіх вершин
- Відображення повних шляхів між вершинами

### Запуск
```bash
python task3/main.py
```

### Приклад виводу
```
==================================================
НАЙКОРОТШІ ШЛЯХИ ВІД 'A'
==================================================

A -> B:
  Відстань: 3
  Шлях: A -> C -> B

A -> C:
  Відстань: 2
  Шлях: A -> C

A -> D:
  Відстань: 8
  Шлях: A -> C -> B -> D

A -> E:
  Відстань: 10
  Шлях: A -> C -> B -> D -> E
```

### Складність
- **Часова**: O((V + E) log V), де V - кількість вершин, E - кількість ребер
- **Просторова**: O(V) для зберігання відстаней та купи

---

## Завдання 4. Візуалізація бінарної купи

### Опис
Програма візуалізує бінарну купу (binary heap), конвертуючи її масивне представлення в дерево та відображаючи його за допомогою NetworkX та matplotlib. Використовується код з LMS як база для побудови та візуалізації дерева.

### Реалізація
- `Node` - клас вузла бінарного дерева з унікальним ідентифікатором та кольором
- `build_heap_tree()` - конвертує масивне представлення купи в дерево
- `add_edges()` - рекурсивно додає ребра до графа для візуалізації
- `draw_tree()` - візуалізує дерево за допомогою NetworkX та matplotlib

### Особливості
- Конвертація масивного представлення купи в структуру дерева
- Автоматичне розташування вузлів у дереві
- Візуалізація з підтримкою кольорів та міток

### Запуск
```bash
python task4/main.py
```
### Складність
- **Часова**: O(n) для побудови дерева, де n - кількість елементів
- **Просторова**: O(n) для зберігання вузлів та графа

---

## Завдання 5. Візуалізація обходу бінарного дерева

### Опис
Програма візуалізує обходи бінарного дерева (DFS та BFS) з кольоровим відображенням вузлів. Кожен вузол отримує унікальний колір, який змінюється від темних до світлих відтінків залежно від порядку обходу. Використовується код з LMS (Завдання 4) як база для побудови та візуалізації дерева.

### Реалізація
- `dfs()` - обхід у глибину з використанням стеку
- `bfs()` - обхід в ширину з використанням черги
- `generate_color()` - генерація кольорів від темних до світлих відтінків (синій - світло-блакитний)
- `draw_tree()` - візуалізація дерева
- `reset_colors()` - скидання кольорів вузлів до значення за замовчуванням

### Особливості
- Використання явного стеку для DFS (не рекурсія)
- Використання черги (`deque`) для BFS
- Градієнт кольорів від темно-синього до світло-блакитного
- Візуалізація обох обходів з окремими вікнами. (приклади відкриваються по черзі, спочатку DFS, потім BFS)

### Запуск
```bash
python task5/main.py
```

### Приклад виводу
```
DFS обхід (у глибину):
Послідовність: [0, 4, 5, 10, 1, 3]

BFS обхід (в ширину):
Послідовність: [0, 4, 1, 5, 10, 3]
```

### Складність
- **DFS**: O(n) за часом, O(h) за пам'яттю (де n - кількість вузлів, h - висота дерева)
- **BFS**: O(n) за часом, O(w) за пам'яттю (де w - максимальна ширина дерева)

---

## Завдання 6. Жадібні алгоритми та динамічне програмування

### Опис
Порівняння жадібного алгоритму та динамічного програмування для задачі вибору продуктів з максимальною калорійністю в межах обмеженого бюджету. Кожен продукт має вартість та калорійність. Задача полягає в максимізації загальної калорійності, не перевищуючи бюджет.

### Вхідні дані
```
items = {
    "pizza": {"cost": 50, "calories": 300},
    "hamburger": {"cost": 40, "calories": 250},
    "hot-dog": {"cost": 30, "calories": 200},
    "pepsi": {"cost": 10, "calories": 100},
    "cola": {"cost": 15, "calories": 220},
    "potato": {"cost": 25, "calories": 350}
}
```


### Реалізація
- `greedy_algorithm()` - жадібний алгоритм, який максимізує співвідношення калорій/вартість
- `dynamic_programming()` - алгоритм динамічного програмування для оптимального рішення
- **Кожен продукт можна вибрати тільки один раз**

### Особливості
- Жадібний алгоритм сортує продукти за співвідношенням калорій/вартість
- Динамічне програмування знаходить глобально оптимальне рішення
- Порівняння результатів обох алгоритмів
- Відображення обраних продуктів, витрат та калорій

### Запуск
```bash
python task6/main.py
```

### Приклад виводу
```
============================================================
ВИБІР ПРОДУКТІВ НА ВКАЗАНИЙ БЮДЖЕТ - 100
============================================================

Жадібний алгоритм:
  Обрані продукти: cola, potato, pepsi, hot-dog
  Витрати: 80
  Калорії: 870

Динамічне програмування (ДП):
  Обрані продукти: potato, cola, pepsi, pizza
  Витрати: 100
  Калорії: 970

Порівняння:
  Різниця в калоріях: 100
  ДП оптимальніший
```

### Складність
- **Жадібний алгоритм**: O(n log n) за часом (сортування), O(n) за пам'яттю
- **Динамічне програмування**: O(n × budget) за часом, O(n × budget) за пам'яттю
