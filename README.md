# GoIT Algorithm Final Project

## Завдання 1. Структури даних. Сортування. Робота з однозв'язним списком

### Опис
Реалізація операцій з однозв'язним списком (singly linked list):
- Реверсія списку шляхом зміни посилань між вузлами
- Сортування списку алгоритмом insertion sort
- Об'єднання двох відсортованих списків в один відсортований

### Реалізація
- `Node` - клас вузла списку
- `LinkedList` - клас однозв'язного списку з методами `append()`, `to_list()`, `from_list()`
- `reverse_list()` - реверсія списку (ітеративний підхід)
- `insertion_sort_list()` - сортування вставками
- `merge_sorted_lists()` - об'єднання двох відсортованих списків

### Запуск
```bash
python task1/main.py
```

### Приклад виводу
```
1. Реверсія:
До: [1, 2, 3, 4, 5]
Після: [5, 4, 3, 2, 1]

2. Сортування:
До: [4, 2, 1, 3, 5]
Після: [1, 2, 3, 4, 5]

3. Об'єднання відсортованих списків:
Список 1: [1, 3, 5]
Список 2: [2, 4, 6]
Об'єднаний: [1, 2, 3, 4, 5, 6]
```

### Складність
- **Реверсія**: O(n) за часом, O(1) за пам'яттю
- **Сортування вставками**: O(n^2) за часом, O(1) за пам'яттю
- **Об'єднання**: O(n + m) за часом, O(1) за пам'яттю (де n, m - довжини списків)

---

## Завдання 2. Рекурсія. Створення фрактала "Дерево Піфагора"

### Опис
Програма генерує фрактал "Дерево Піфагора" за допомогою рекурсії та візуалізує його за допомогою бібліотеки `turtle`. Користувач може вказати рівень рекурсії для контролю складності фракталу.

![Дерево Піфагора (рівень 10)](pythagorean_tree_10.png)

### Особливості
- Рекурсивна генерація фракталу
- Змінна ширина ліній: товстіші на початкових рівнях, тонші на глибоких
- Кожна гілка має кут 45(deg) і зменшується на 30% (коефіцієнт 0.7) на кожному рівні

### Запуск
```bash
python task2/main.py
```

### Параметри
- **Рівень рекурсії**: вводиться користувачем (за замовчуванням 5)
- **Початкова довжина**: 100 пікселів
- **Коефіцієнт зменшення**: 0.7
- **Кут розгалуження**: 45(deg)

### Алгоритм
1. Малюється вертикальна лінія (стовбур)
2. На кожному рівні рекурсії створюються дві гілки під кутом 45(deg)
3. Довжина гілок зменшується на 30% на кожному рівні
4. Процес повторюється до досягнення глибини 0

### Складність
- **Часова**: O(2^n), де n - рівень рекурсії
- **Просторова**: O(n) через стек рекурсивних викликів

---

## Завдання 3. Дерева, алгоритм Дейкстри

### Опис
Реалізація алгоритму Дейкстри для знаходження найкоротших шляхів у зваженому графі з використанням бінарної купи (піраміди). Алгоритм обчислює найкоротші відстані від початкової вершини до всіх інших вершин графа.

### Реалізація
- `dijkstra()` - алгоритм Дейкстри з використанням бінарної купи (`heapq`)
- `get_path()` - відновлення шляху від початкової до цільової вершини
- Граф представлений як словник, де ключі - вершини, значення - словники сусідів з вагами ребер

### Особливості
- Використання бінарної купи (min-heap) для оптимізації вибору вершин
- Автоматичне обчислення найкоротших шляхів до всіх вершин
- Відображення повних шляхів між вершинами

### Запуск
```bash
python task3/main.py
```

### Приклад виводу
```
==================================================
НАЙКОРОТШІ ШЛЯХИ ВІД 'A'
==================================================

A -> B:
  Відстань: 3
  Шлях: A -> C -> B

A -> C:
  Відстань: 2
  Шлях: A -> C

A -> D:
  Відстань: 8
  Шлях: A -> C -> B -> D

A -> E:
  Відстань: 10
  Шлях: A -> C -> B -> D -> E
```

### Складність
- **Часова**: O((V + E) log V), де V - кількість вершин, E - кількість ребер
- **Просторова**: O(V) для зберігання відстаней та купи

---

## Завдання 4. Візуалізація бінарної купи

### Опис
Програма візуалізує бінарну купу (binary heap), конвертуючи її масивне представлення в дерево та відображаючи його за допомогою NetworkX та matplotlib. Використовується код з LMS як база для побудови та візуалізації дерева.

### Реалізація
- `Node` - клас вузла бінарного дерева з унікальним ідентифікатором та кольором
- `build_heap_tree()` - конвертує масивне представлення купи в дерево
- `add_edges()` - рекурсивно додає ребра до графа для візуалізації
- `draw_tree()` - візуалізує дерево за допомогою NetworkX та matplotlib

### Особливості
- Конвертація масивного представлення купи в структуру дерева
- Автоматичне розташування вузлів у дереві
- Візуалізація з підтримкою кольорів та міток

### Запуск
```bash
python task4/main.py
```
### Складність
- **Часова**: O(n) для побудови дерева, де n - кількість елементів
- **Просторова**: O(n) для зберігання вузлів та графа

---

## Завдання 5. Візуалізація обходу бінарного дерева

### Опис
Програма візуалізує обходи бінарного дерева (DFS та BFS) з кольоровим відображенням вузлів. Кожен вузол отримує унікальний колір, який змінюється від темних до світлих відтінків залежно від порядку обходу. Використовується код з LMS (Завдання 4) як база для побудови та візуалізації дерева.

### Реалізація
- `dfs()` - обхід у глибину з використанням стеку
- `bfs()` - обхід в ширину з використанням черги
- `generate_color()` - генерація кольорів від темних до світлих відтінків (синій - світло-блакитний)
- `draw_tree()` - візуалізація дерева
- `reset_colors()` - скидання кольорів вузлів до значення за замовчуванням

### Особливості
- Використання явного стеку для DFS (не рекурсія)
- Використання черги (`deque`) для BFS
- Градієнт кольорів від темно-синього до світло-блакитного
- Візуалізація обох обходів з окремими вікнами. (приклади відкриваються по черзі, спочатку DFS, потім BFS)

### Запуск
```bash
python task5/main.py
```

### Приклад виводу
```
DFS обхід (у глибину):
Послідовність: [0, 4, 5, 10, 1, 3]

BFS обхід (в ширину):
Послідовність: [0, 4, 1, 5, 10, 3]
```

### Складність
- **DFS**: O(n) за часом, O(h) за пам'яттю (де n - кількість вузлів, h - висота дерева)
- **BFS**: O(n) за часом, O(w) за пам'яттю (де w - максимальна ширина дерева)

---

## Завдання 6. Жадібні алгоритми та динамічне програмування

### Опис
Порівняння жадібного алгоритму та динамічного програмування для задачі вибору продуктів з максимальною калорійністю в межах обмеженого бюджету. Кожен продукт має вартість та калорійність. Задача полягає в максимізації загальної калорійності, не перевищуючи бюджет.

### Вхідні дані
```
items = {
    "pizza": {"cost": 50, "calories": 300},
    "hamburger": {"cost": 40, "calories": 250},
    "hot-dog": {"cost": 30, "calories": 200},
    "pepsi": {"cost": 10, "calories": 100},
    "cola": {"cost": 15, "calories": 220},
    "potato": {"cost": 25, "calories": 350}
}
```


### Реалізація
- `greedy_algorithm()` - жадібний алгоритм, який максимізує співвідношення калорій/вартість
- `dynamic_programming()` - алгоритм динамічного програмування для оптимального рішення
- **Кожен продукт можна вибрати тільки один раз**

### Особливості
- Жадібний алгоритм сортує продукти за співвідношенням калорій/вартість
- Динамічне програмування знаходить глобально оптимальне рішення
- Порівняння результатів обох алгоритмів
- Відображення обраних продуктів, витрат та калорій

### Запуск
```bash
python task6/main.py
```

### Приклад виводу
```
============================================================
ВИБІР ПРОДУКТІВ НА ВКАЗАНИЙ БЮДЖЕТ - 100
============================================================

Жадібний алгоритм:
  Обрані продукти: cola, potato, pepsi, hot-dog
  Витрати: 80
  Калорії: 870

Динамічне програмування (ДП):
  Обрані продукти: potato, cola, pepsi, pizza
  Витрати: 100
  Калорії: 970

Порівняння:
  Різниця в калоріях: 100
  ДП оптимальніший
```

### Складність
- **Жадібний алгоритм**: O(n log n) за часом (сортування), O(n) за пам'яттю
- **Динамічне програмування**: O(n × budget) за часом, O(n × budget) за пам'яттю

---

## Завдання 7. Використання методу Монте-Карло

### Опис
Симуляція великої кількості кидків двох кубиків методом Монте-Карло для обчислення ймовірностей кожної можливої суми (від 2 до 12). Програма порівнює результати симуляції з аналітичними розрахунками та візуалізує їх на графіку.

### Візуалізація
![Порівняння ймовірностей: Монте-Карло vs Аналітичний розрахунок](dice_probabilities.png)

### Реалізація
- `simulate_dice_rolls()` - симуляція кидків двох кубиків та підрахунок сум
- `calculate_probabilities()` - обчислення ймовірностей на основі симуляції
- `analytical_probabilities()` - табличні дані аналітичних ймовірностей (з довідкової таблиці LMS)
- `print_results()` - виведення результатів у вигляді таблиці
- `plot_results()` - побудова графіка порівняння результатів

### Особливості
- Симуляція 100,000 кидків двох кубиків
- Порівняння результатів Монте-Карло з аналітичними розрахунками
- Візуалізація результатів на графіку
- Обчислення відхилень між симуляцією та аналітичними значеннями

### Запуск
```bash
python task7/main.py
```

### Аналітичні ймовірності (табличні дані)
Для двох кубиків існує 36 можливих комбінацій. Таблиця аналітичних ймовірностей:

| Сума | Імовірність | Комбінації |
|------|-------------|------------|
| 2    | 2.78% (1/36) | 1+1 |
| 3    | 5.56% (2/36) | 1+2, 2+1 |
| 4    | 8.33% (3/36) | 1+3, 2+2, 3+1 |
| 5    | 11.11% (4/36) | 1+4, 2+3, 3+2, 4+1 |
| 6    | 13.89% (5/36) | 1+5, 2+4, 3+3, 4+2, 5+1 |
| 7    | 16.67% (6/36) | 1+6, 2+5, 3+4, 4+3, 5+2, 6+1 |
| 8    | 13.89% (5/36) | 2+6, 3+5, 4+4, 5+3, 6+2 |
| 9    | 11.11% (4/36) | 3+6, 4+5, 5+4, 6+3 |
| 10   | 8.33% (3/36) | 4+6, 5+5, 6+4 |
| 11   | 5.56% (2/36) | 5+6, 6+5 |
| 12   | 2.78% (1/36) | 6+6 |

**Найбільша ймовірність**: Сума 7 має найбільшу ймовірність (16.67%), оскільки може бути отримана найбільшою кількістю способів (6 комбінацій).

### Висновки щодо правильності розрахунків

**Порівняння методів:**
1. **Точність методу Монте-Карло**: При 100,000 симуляціях результати методу Монте-Карло дуже близькі до аналітичних розрахунків. Відхилення зазвичай не перевищують 0.2-0.3%, що підтверджує правильність реалізації.

2. **Закон великих чисел**: Зі збільшенням кількості симуляцій (>100,000) результати Монте-Карло наближаються до аналітичних значень. Це демонструє дію закону великих чисел.

3. **Найбільша ймовірність**: Обидва методи підтверджують, що сума 7 має найбільшу ймовірність (~16.67%), оскільки вона може бути отримана найбільшою кількістю способів (6 комбінацій).

4. **Симетричність розподілу**: Розподіл ймовірностей симетричний відносно суми 7, що підтверджується як симуляцією, так і аналітичними розрахунками.

5. **Валідація методу**: Малі відхилення між результатами Монте-Карло та аналітичними розрахунками підтверджують правильність реалізації методу та коректність генератора випадкових чисел.

**Висновок**: Метод Монте-Карло успішно апроксимує теоретичні ймовірності з високою точністю при достатній кількості симуляцій, що підтверджує його ефективність для обчислення ймовірностей у складніших задачах, де аналітичні розрахунки неможливі або надто складні.

### Складність
- **Часова**: O(n), де n - кількість симуляцій
- **Просторова**: O(1) для зберігання сум (11 можливих)
